# 関数型言語としての Javascript

## なぜ Javascript なのか？

**Javascript があらゆる場所で使われているから**
Web の言語で他に類を見ない普及率を持っている。

Javascript は、オブジェクト指向かつ関数型言語でもある。

## 関数型プログラミング vs オブジェクト指向プログラミング

> [!NOTE]
> オブジェクト内のデータへアクセスする際に `this` の利用を避ける！
> メソッドスコープ以外のインスタンスへアクセスすることができるため、副作用を起こしてしまい、純粋関数ではなくなる。

**オブジェクト指向プログラミング（OOP）**では、データとそれに関連する処理をオブジェクトにカプセル化します。
このアプローチの利点は、データと操作を一つのユニットとして扱うことができる点です。
しかし、この方法では、同じ処理を異なるオブジェクトで実行したい場合、それぞれのオブジェクトに対して同じ処理を再実装する必要があることがあります。
これにより、コードの重複が発生し、保守性が低下する可能性があります。

例えば、Male と Female という2つのオブジェクトがあり、これらに共通する処理として walk メソッドがあるとします。
オブジェクト指向では、これらのオブジェクトのスーパークラス（例えば Human）を作成し、共通の walk メソッドをそのスーパークラスに定義します。
このように、オブジェクト指向プログラミングでは、継承を利用して処理を抽象化し、コードの再利用を促進します。

一方、**関数型プログラミング（FP）**では、データと処理を分離し、処理を関数として表現します。
例えば、walk という関数を作成し、Human、Dog、Cat など、歩行可能なあらゆるオブジェクトに対して再利用できるようにします。
関数型プログラミングでは、引数の型を一般化し、再利用性の高いコードを実現します。
ここで言う「Human みたいな引数」とは、walk 関数が人間以外の動物にも適用可能であることを意味しています。
つまり、関数型プログラミングでは、より汎用的な関数を定義することで抽象化を行います。

プログラミングにおいては、コードの重複を減らし、再利用可能で保守性の高いコードを作成することが重要です。
そのため、処理の抽象化が必要であり、この抽象化の方法がオブジェクト指向と関数型プログラミングで異なります。

## Javascript オブジェクトの状態管理

Javascript はオブジェクトのプロパティは動的で追加・削除・変更が可能です。
たとえクラスのインスタンス変数がプライベートであっても、外部からアクセスし、変更できてしまいます。
この仕様は、状態管理を行う上で最悪と言えます。

> [!NOTE]
> ES2022 からは、`#` を使ってプライベートフィールドを定義できるようになっている。
> 公式 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_properties

## オブジェクトを値として扱う

**関数型プログラミングにおける値とは、数値や文字列のようなプリミティブなデータ型で本質的に不変であるものを指します。**
Javascript における動的なデータ構造を持つ、オブジェクトを値のように扱うことで、堅牢な状態管理を可能にする。

> [!NOTE] 前提として、Javascript のクラスによって作られるオブジェクトは、値として扱えない。
> 外から直接インスタンス変数を書き換えることができるため

### クロージャーを使う

クロージャーは、関数とその関数が作られた環境（スコープ）を持つオブジェクトです。

```javascript
const createPerson = (name, age) => {
    let _name = name;
    let _age = age;

    return {
        getName: () => _name,
        getAge: () => _age,
        setName: (name) => _name = name,
        setAge: (age) => _age = age
    };
}
```

### 可動部をディープフリーズ ( 再起的にフリーズ )

クラス文法でも、プロパティを不変にすることは `Object.freeze` を利用すれば可能。
しかしこれは、 Shallow Freeze であり、オブジェクトのプロパティがオブジェクトである場合は、そのプロパティはフリーズされない。

### ディープフリーズを自作する

```javascript
const isObject = (obj) => obj !== null && typeof obj === 'object';

const deepFreeze = (obj) => {
    if (isObject(obj) && !Object.isFrozen(obj)) {
        Object.freeze(obj);
        Object.keys(obj).forEach(key => deepFreeze(obj[key]));
    }

    return obj;
}
```

### レンズを使ってオブジェクトグラフを操作

オブジェクト指向では、状態をメソッドによって変更を行うが、状態が正しく変更されたかどうかを確認することが難しい。
**コピーオンライト（ 書き込み時にコピーすること ) ** という戦略に基づき、各メソッド呼び出しから新たなオブジェクトを返すような実装も可能だが、冗長でエラーの温床となる。
状態を持つオブジェクトを不変に保ちつつ、状態を変更するための方法として、**レンズ** という概念がある。
レンズは、自前で実装することなく、ライブラリを使用して実装することができる。

```javascript
const person = new Person('Alonzo', 'Church', '444-44-4444');
const lastnameLens = R.lensProp('lastname');
```

上記プログラムでは、 `R.lensProp` で `lastname` プロパティに対するレンズを作成している。

```javascript
R.view(lastnameLens, person); // Church
```

`R.view` によって、このプロパティを読み込む小音ができる。

```javascript
const newPerson = R.set(lastnameLens, 'Mourning', person);
newPerson.lastname // Mourning
person.lastname // Church
```

`R.set` によって新たな値を持ったオブジェクトを作成することができる。
さらに元のインスタンスの状態も保持することができている。
つまりコピーオンライトを実現している。

レンズは、初めての概念なので理解が浅い。
別で時間をとって詳しく調べる必要がある。

## 関数

**関数とは、`()` 演算子によって評価される呼び出し可能な式の事です。**
関数型プログラミングでは、常に関数を有効な値を生成する手段として扱います。
よって void のような undefined を返す関数は避けるべきです。

> [!NOTE]
> 式は、値を返すが、文は値を返さない。

手続き型は、順番に連続した文で構成され、関数型は、式で構成される。

### 第一級オブジェクトとしての関数

Javascript では、関数もオブジェクトであり、変数に代入したり、引数として渡したり、関数から返したりすることが可能。

```javascript
const add = (a, b) => a + b;
const callFuction = (fn, a, b) => fn(a, b);
const returnFunction = () => add;
const obj = {
    add: add
};
```

### 高階関数

上記で説明した通り、関数はオブジェクトであるため、関数を引数に取ったり、戻り値として返すことができる。
このような関数を **高階関数** と呼ぶ。

```javascript

const applyOperation = (a, b, fn) => fn(a, b);
const multiplier = (a, b) => a * b;
applyOperation(2, 3, multiplier); // 6
```



